---
title: "Node Examples"
author: "Christoph Glur"
date: "2.2.2015"
output: html_document
---

## Creating a Tree

Let's start by creating a tree of nodes. In our example, we are looking at a company, Acme Inc., and the tree reflects its oranisational structure. On level 1, the nodes represent departments, and the leaves of the tree represent projects the company considers for next year.

```{r}
library(ahp)
acme <- Node$new("Acme Inc.")
  accounting <- acme$AddChild("Accounting")
    software <- accounting$AddChild("New Software")
    standards <- accounting$AddChild("New Accounting Standards")
  research <- acme$AddChild("Research")
    newProductLine <- research$AddChild("New Product Line")
    newLabs <- research$AddChild("New Labs")
  it <- acme$AddChild("IT")
    outsource <- it$AddChild("Outsource")
    agile <- it$AddChild("Go agile")
    goToR <- it$AddChild("Switch to R")

print(acme)
  
```
## Setting Custom Attributes

Now, let's associate some costs with the projects:
```{r}
software$cost <- 1000000
standards$cost <- 500000
newProductLine$cost <- 2000000
newLabs$cost <- 750000
outsource$cost <- 400000
agile$cost <- 250000
goToR$cost <- 50000

```
And some probabilities that the projecs will be executed in the next year:

```{r}
software$p <- 0.5
standards$p <- 0.75
newProductLine$p <- 0.25
newLabs$p <- 0.9
outsource$p <- 0.2
agile$p <- 0.05
goToR$p <- 1

```

## Converting to data.frame

We can now convert the tree into a data.frame:

```{r}
acmedf <- as.data.frame(acme)
acmedf

```
Adding the cost is easy:
```{r}
acmedf$cost <- acme$Flatten("cost")
```

We could have achieved the same result in one go:
```{r}
acmedf <- as.data.frame(acme, cols = c("level", "cost"))
acmedf
```

## Formatting Output

We can use formating numbers to pretty print the output:

```{r}
PrintMoney <- function(x) {
  format(x, digits=10, nsmall=2, decimal.mark=".", big.mark="'", scientific = FALSE)
}


acmedf <- as.data.frame(acme, 
                        cols = c("level", "cost", probability = "p"),
                        format = c(cost = PrintMoney, probability = FormatPercent))

acmedf
```

## Custom Methods

If we want to add a custom method to our node class, we can create a subclass.

```{r}
library(R6)
MyNode <- R6Class("MyNode",
                    inherit = Node,
                    lock = FALSE,
                    
                    #public fields and function
                    public = list(
                        p = NULL, 
                        cost = NULL,
                        AddChild = function(name) {
                          child <- MyNode$new(name)
                          invisible (self$AddChildNode(child))
                        }
                    ),
                    
                    #active
                    active = list(
                      expectedCost = function() {
                        if ( any(sapply(list(self$p, self$cost), is.null))) return (NULL)
                        self$p * self$cost                    
                      }
                    )
                )

```

The AddChild utility function in the subclass allows us to construct the tree just as before:

```{r}


acme <- MyNode$new("Acme Inc.")
  accounting <- acme$AddChild("Accounting")
    software <- accounting$AddChild("New Software")
    standards <- accounting$AddChild("New Accounting Standards")
  research <- acme$AddChild("Research")
    newProductLine <- research$AddChild("New Product Line")
    newLabs <- research$AddChild("New Labs")
  it <- acme$AddChild("IT")
    outsource <- it$AddChild("Outsource")
    agile <- it$AddChild("Go agile")
    goToR <- it$AddChild("Switch to R")

```

From a user's perspective, setting attributes is the same, regardless of whether the attribute was defined in the class like here, or whether the attribute was patched onto the object after construction (as above):


```{r}


software$cost <- 1000000
standards$cost <- 500000
newProductLine$cost <- 2000000
newLabs$cost <- 750000
outsource$cost <- 400000
agile$cost <- 250000
goToR$cost <- 50000

software$p <- 0.5
standards$p <- 0.75
newProductLine$p <- 0.25
newLabs$p <- 0.9
outsource$p <- 0.2
agile$p <- 0.05
goToR$p <- 1
```

MyNode now subclasses Node:

```{r}
class(agile)
```


We can now call the function directly on the instance:

```{r}
agile$expectedCost == agile$p * agile$cost
```


## Aggregation

The Aggregate method allows applying a function to a node's children, whereby the children's value again may come from an aggregate. This is best explained by example. Assume we want to sum up the costs along the tree. For a single node, this is achieved like this:

```{r}
accounting$Aggregate("cost", sum)
```

The Aggregate method is smart enough to iterate through childs recursively, until the requested attribut is not null. This allows us to aggregate e.g. the cost for the entire company:

```{r}
acme$Aggregate("cost", mean)
```

However, we can actively make the iteration stop by setting a specific value:

```{r}

accounting$cost <- 5000000
acme$Aggregate("cost", mean)
accounting$cost <- NULL
acme$Aggregate("cost", mean)
```


Of course, we can also use the custom property expectedCost in the aggregate function:
```{r}
it$Aggregate("expectedCost", sum)
```


We can Flatten using the Aggregate function:

```{r}
acme$Flatten("Aggregate", "cost", sum)

```
Or, directly as a data.frame:

```{r}
stop("DOESN?T WORK!")
acmedf <- as.data.frame(acme, 
                        cols = c("level", cost = "Aggregate", probability = "p"),
                        args = list(cost = c("cost", sum)),
                        format = c(cost = PrintMoney, probability = FormatPercent))


IDEA: instead use 


acmedf <- as.data.frame(acme, 
                        "level", #by default, column name = variable name
                        cost = c(args = "Aggregate", format = PrintMoney, "cost", sum), #but you can provide a name, and add ...
                        probability = c("p", FormatPercent)
                        )
acmedf
```



