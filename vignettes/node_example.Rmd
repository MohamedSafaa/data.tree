---
title: "Node Examples"
author: "Christoph Glur"
date: '`r Sys.Date()`'
output:
  pdf_document:
    highlight: tango
    toc: yes
    toc_depth: 4
  html_document:
    theme: united
    toc: yes
    toc_depth: 4
  word_document: default
vignette: |
  %\VignetteIndexEntry{Vignette Title} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---

## Creating a Tree

Let's start by creating a tree of nodes. In our example, we are looking at a company, Acme Inc., and the tree reflects its oranisational structure. On level 1, the nodes represent departments, and the leaves of the tree represent projects the company considers for next year.

```{r}
library(ahp)
acme <- Node$new("Acme Inc.")
  accounting <- acme$AddChild("Accounting")
    software <- accounting$AddChild("New Software")
    standards <- accounting$AddChild("New Accounting Standards")
  research <- acme$AddChild("Research")
    newProductLine <- research$AddChild("New Product Line")
    newLabs <- research$AddChild("New Labs")
  it <- acme$AddChild("IT")
    outsource <- it$AddChild("Outsource")
    agile <- it$AddChild("Go agile")
    goToR <- it$AddChild("Switch to R")

print(acme)
  
```
## Setting Custom Attributes

Now, let's associate some costs with the projects:
```{r}
software$cost <- 1000000
standards$cost <- 500000
newProductLine$cost <- 2000000
newLabs$cost <- 750000
outsource$cost <- 400000
agile$cost <- 250000
goToR$cost <- 50000

```
And some probabilities that the projecs will be executed in the next year:

```{r}
software$p <- 0.5
standards$p <- 0.75
newProductLine$p <- 0.25
newLabs$p <- 0.9
outsource$p <- 0.2
agile$p <- 0.05
goToR$p <- 1

```

## Converting to data.frame

We can now convert the tree into a data.frame:

```{r}
acmedf <- as.data.frame(acme)
acmedf

```
Adding the cost is easy:
```{r}
acmedf$cost <- acme$Flatten("cost")
acmedf
```

We could have achieved the same result in one go:
```{r}
acmedf <- as.data.frame(acme, "level", "cost")
acmedf
```

## Formatting Output

We can use formating functions to pretty print the output:

```{r}
PrintMoney <- function(x) {
  format(x, digits=10, nsmall=2, decimal.mark=".", big.mark="'", scientific = FALSE)
}


acmedf <- as.data.frame(acme, 
                          "level", 
                          c("cost", format = PrintMoney), 
                          probability = c("p", format = FormatPercent)
                        )
acmedf
```

## Custom Methods

If we want to add a custom method to our node class, we can create a subclass.

```{r}
library(R6)
MyNode <- R6Class("MyNode",
                    inherit = Node,
                    lock = FALSE,
                    
                    #public fields and function
                    public = list(
                        p = NULL, 
                        cost = NULL,
                        AddChild = function(name) {
                          child <- MyNode$new(name)
                          invisible (self$AddChildNode(child))
                        }
                    ),
                    
                    #active
                    active = list(
                      expectedCost = function() {
                        if ( any(sapply(list(self$p, self$cost), is.null))) return (NULL)
                        self$p * self$cost                    
                      }
                    )
                )

```

The AddChild utility function in the subclass allows us to construct the tree just as before:

```{r}


acme <- MyNode$new("Acme Inc.")
  accounting <- acme$AddChild("Accounting")
    software <- accounting$AddChild("New Software")
    standards <- accounting$AddChild("New Accounting Standards")
  research <- acme$AddChild("Research")
    newProductLine <- research$AddChild("New Product Line")
    newLabs <- research$AddChild("New Labs")
  it <- acme$AddChild("IT")
    outsource <- it$AddChild("Outsource")
    agile <- it$AddChild("Go agile")
    goToR <- it$AddChild("Switch to R")

```

From a user's perspective, setting attributes is the same, regardless of whether the attribute was defined in the class like here, or whether the attribute was patched onto the object after construction (as above):


```{r}


software$cost <- 1000000
standards$cost <- 500000
newProductLine$cost <- 2000000
newLabs$cost <- 750000
outsource$cost <- 400000
agile$cost <- 250000
goToR$cost <- 50000

software$p <- 0.5
standards$p <- 0.75
newProductLine$p <- 0.25
newLabs$p <- 0.9
outsource$p <- 0.2
agile$p <- 0.05
goToR$p <- 1
```

MyNode now subclasses Node:

```{r}
class(agile)
```


We can now call the function directly on the instance:

```{r}
agile$expectedCost == agile$p * agile$cost
```


## Aggregation

The Aggregate method allows applying a function to a node's children, whereby the children's value again may come from an aggregate. This is best explained by example. Assume we want to sum up the costs along the tree. For a single node, this is achieved like this:

```{r}
accounting$Aggregate("cost", sum)
```

The Aggregate method is smart enough to iterate through childs recursively, until the requested attribut is not null. This allows us to aggregate e.g. the cost for the entire company:

```{r}
acme$Aggregate("cost", mean)
```

However, we can actively make the iteration stop by setting a specific value:

```{r}

accounting$cost <- 5000000
acme$Aggregate("cost", mean)
accounting$cost <- NULL
acme$Aggregate("cost", mean)
```


Of course, we can also use the custom property expectedCost in the aggregate function:
```{r}
it$Aggregate("expectedCost", sum)
acme$Aggregate("expectedCost", max)
```


### Print aggregate function

We can Flatten using the Aggregate function:

```{r}
acme$Flatten("Aggregate", "expectedCost", sum)

```
Or, directly as a data.frame:

```{r}

acmedf <- as.data.frame(acme, 
                        "level",
                        cost = list("Aggregate", args = c("cost", sum), format = PrintMoney),
                        probability = list("p", format = FormatPercent),
                        ec = list("Aggregate", args = c("expectedCost", sum), format = PrintMoney)
                        )
                        
acmedf
```


An alternative way to achieve the same thing using the magrittr package is:

```{r}
library(magrittr)
as.data.frame(acme) %>% 
  cbind(level = acme$Flatten("level")) %>%
  cbind(cost = acme$Flatten("Aggregate", "cost", sum) %>% PrintMoney) %>% 
  cbind(p = acme$Flatten("p") %>% FormatPercent) %>% 
  cbind(ec = acme$Flatten("Aggregate", "expectedCost", sum) %>% PrintMoney) -> acmedf
```

## Traject parents

The Traject method is similar to the Flatten, except that it moves in the other direction, from a child to its parent.
For example, let's consider the following manager salaries:
```{r}
acme$managerSalary <- 250000
accounting$managerSalary <- 100000
research$managerSalary <- 125000
it$managerSalary <- 90000

```

Then, salaries of the IT and above are:

```{r}
it$Traject("managerSalary")
```


## Sorting

You can sort an entire tree by using the Sort method on the root. The method will iterate through children and, for each node, sort the children by a child attribute. As before, the child attribute can also be a function. 

```{r}
acme$Sort("expectedCost")
as.data.frame(acme, "expectedCost")
```

Using the Aggregate method makes the Sort even more useful:

```{r}
acme$Sort("Aggregate", "expectedCost", sum, decreasing = TRUE)
as.data.frame(acme, ec = list("Aggregate", c("expectedCost", sum), PrintMoney))
```

