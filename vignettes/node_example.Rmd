---
title: "Node Examples"
author: "Christoph Glur"
date: '`r Sys.Date()`'
output:
  pdf_document:
    highlight: tango
    toc: yes
    toc_depth: 4
  html_document:
    theme: united
    toc: yes
    toc_depth: 4
  word_document: default
vignette: |
  %\VignetteIndexEntry{Vignette Title} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---

## About Trees

Trees are ubiquitious is mathematics, computer science, data sciences, finance, and in many other fields. Trees are useful always when we are facing hierarchies. Some examples where trees are useful:

* in decision theory (c.f. decision trees)
* in finance, e.g. to classify financial instruments into asset classes
* in routing algorithms
* in computer science and programming (e.g. binary search trees, xml)
* e.g. for family trees

R provides some tree-like structures on various low levels. For example, environments can be seen as nodes in a tree. Also, R provides various packages that deal with tree-like structures (especially in the area of decision theory). Yet, there is no high-level tree data structure that could be used equally conveniently and generically as, say, data.frame. 

As a consequence, people often try to resolve hierarchical problems in data.frames (or in Excel sheets). But hierarchies don't marry with tables and various workarounds are usually required. 

This package tries to offer an alternative. The tree package allows creating hierarchies by the use of the Node object. Node provides basic traversal and search operations. You can decorate Nodes with attributes and methods, by that extending the package to your needs. 

Also, the package provides convenience methods to print trees nicely.

## Creating a Tree

Let's start by creating a tree of nodes. In our example, we are looking at a company, Acme Inc., and the tree reflects its oranisational structure. On level 1, the nodes represent departments, and the leaves of the tree represent projects the company considers for next year.

```{r}
library(ahp)
acme <- Node$new("Acme Inc.")
  accounting <- acme$AddChild("Accounting")
    software <- accounting$AddChild("New Software")
    standards <- accounting$AddChild("New Accounting Standards")
  research <- acme$AddChild("Research")
    newProductLine <- research$AddChild("New Product Line")
    newLabs <- research$AddChild("New Labs")
  it <- acme$AddChild("IT")
    outsource <- it$AddChild("Outsource")
    agile <- it$AddChild("Go agile")
    goToR <- it$AddChild("Switch to R")

print(acme)
  
```
## Setting Custom Attributes

Now, let's associate some costs with the projects:
```{r}
software$cost <- 1000000
standards$cost <- 500000
newProductLine$cost <- 2000000
newLabs$cost <- 750000
outsource$cost <- 400000
agile$cost <- 250000
goToR$cost <- 50000

```
And some probabilities that the projecs will be executed in the next year:

```{r}
software$p <- 0.5
standards$p <- 0.75
newProductLine$p <- 0.25
newLabs$p <- 0.9
outsource$p <- 0.2
agile$p <- 0.05
goToR$p <- 1

```

## Converting to data.frame

We can now convert the tree into a data.frame:

```{r}
acmedf <- as.data.frame(acme)
acmedf

```
Adding the cost is easy, by using the Traverse method, which will be explained in more detail below:
```{r}
acmedf$level <- acme$Traverse("level")
acmedf$cost <- acme$Traverse("cost")
acmedf
```

We could have achieved the same result in one go:
```{r}
as.data.frame(acme, "level", "cost")
```

## Traverse

Tree traversal is one of the core concepts of trees. See for example here: http://en.wikipedia.org/wiki/Tree_traversal 

### Traversal Mode

#### Pre-Order

The default traversal mode is pre-order. This is what is used e.g. in the as.data.frame method:

```{r}
as.data.frame(acme, "level")

data.frame(level = acme$Traverse('level'))

```

#### Post-Order

The post-order traversal mode first returns children:

```{r}
data.frame(level = acme$Traverse('level', mode = "post-order"))
```

#### Ancestor

The ancestor mode starts from a node, and then walks the tree along the path from ancestor to ancestor, up to the root:

```{r}

data.frame(level = agile$Traverse('level', mode = "ancestor"))

```

### Traverse using a function

#### Pass a function to the Traverse method

You can pass a standard R function to the Traverse method. For example:

```{r}
library(magrittr)
ExpectedCost <- function(node) {
  result <- node$cost * node$p
  if(length(result) == 0) result <- NA
  return (result)
}

acme$Traverse(ExpectedCost) %>% as.data.frame

```

The requirement for the function (ExpectedCost in the above example) is that:
* the first argument of the function is a Node
* it needs to return a scalar


#### Use Recursion

```{r}
ExpectedCost <- function(node) {
  result <- node$cost * node$p
  if(length(result) == 0) {
    if (node$isLeaf) result <- NA
    else {
      node$children %>% sapply(ExpectedCost) %>% sum -> result
    }
  }
  return (result)
}

acme$Traverse(ExpectedCost) %>% as.matrix

```

#### Add Parameters to the Passed Function

The Traverse method accepts an ellipsis (...). Any additional parameters with which Traverse is called will be passed on the the ExpectedCost function: This allows us to make this more flexible:

```{r}

ExpectedCost <- function(node, fun = sum) {
  result <- node$cost * node$p
  if(length(result) == 0) {
    if (node$isLeaf) result <- NA
    else {
      node$children %>% sapply(function(x) ExpectedCost(x, fun = fun)) %>% fun -> result
    }
  }
  return (result)
}

acme$Traverse(ExpectedCost, fun = mean) %>% as.matrix

```


### Assigning values using Traverse

We can use Traverse to assign properties of our Node objects:

```{r}

acme$Traverse(function(x) x$p * x$cost, assign = "expectedCost")
as.data.frame(acme, "p", "cost", "expectedCost")

```

### Combine Assignment and Calculation

In the above Recursion example, we recurse for each node to all descendants straight to the leaf, by that repeating the same calculations various times.

We can avoid these repetitious calculations by piggy-backing on pre-calculated values. Obviously, this requires us to traverse the tree in post-order mode: We want to start calculating at the leafes, and then walk back towards the root.

In the following example, we calculate the average expected cost. As this depends now only of a node's children, and because we walk the tree in post-order mode, we can be sure that our children have the value calculated when we traverse the parent.


```{r}

ExpectedCost <- function(node, variableName = "avgExpectedCost", fun = sum) {
  #if the "cache" is filled, I return it. This stops the recursion
  if(!is.null(node[[variableName]])) return (node[[variableName]])
  
  #otherwise, I calculate from my own properties
  result <- node$cost * node$p
  
  #if the properties are not set, I calculate the mean from my children
  if(length(result) == 0) {
    if (node$isLeaf) result <- NA
    else {
      node$children %>%
      sapply(function(x) ExpectedCost(x, variableName = variableName, fun = fun)) %>%
      fun -> result
    }
  }
  return (result)
}

acme$Traverse(ExpectedCost, fun = mean, mode = "post-order", assign = "avgExpectedCost")

acme$Traverse("avgExpectedCost") %>% as.data.frame

```

### Deleting Attributes

The Traverse method can also be used to assign a value directly. For example, to remove the avgExpectedCost, we assign NULL on each node like this:

```{r}
acme$Traverse(NULL, assign = "avgExpectedCost") %>% as.matrix
acme$Traverse("avgExpectedCost") %>% as.matrix

```


### Formatting Traverse

We can pass a formatting function to the traverse, which will convert the returned value for printing. 

```{r}

PrintMoney <- function(x) {
  format(x, digits=10, nsmall=2, decimal.mark=".", big.mark="'", scientific = FALSE)
}

acme$Traverse("cost", format = PrintMoney) %>% as.data.frame

```

Note that the format is not used for assignment with the assign parameter.

### Using Traverse when converting to data.frame and for printing

Above, we saw how we can add the name of an attribute to the ellipsis argument of the as.data.frame. However, we can also add the results of the Traverse method to the as.data.frame, but that giving us full flexibilitiy:

```{r}

as.data.frame(acme, 
              "level",
              cost = acme$Traverse("cost", format = PrintMoney),
              probability = acme$Traverse("p", format = FormatPercent)
             )
                        

```

## Aggregate

For simple cases, you don't have to write your own function to pass along to the Traverse method. For example, the Aggregate method provides a shorthand for the often used case when a parent is the aggregate of its children values:

```{r}

acme$Aggregate("cost", sum)

```

We can use this in the Traverse method:

```{r}
acme$Traverse("Aggregate", "cost", sum)
```

This is equivalent of:

```{r}

GetCost <- function(node) {
  result <- node$cost
  if(length(result) == 0) {
    if (node$isLeaf) stop(paste("Cost for ", node$name, " not available!"))
    else {
      node$children %>% sapply(GetCost) %>% sum -> result
    }
  }
  return (result)
}

acme$Traverse(GetCost)

```


## Sorting

You can sort an entire tree by using the Sort method on the root. The method will sort recursively and, for each node, sort the children by a child attribute. As before, the child attribute can also be a function or a method (e.g. of a sub class of Node, see below).

```{r}
acme$Traverse(ExpectedCost, assign = "expectedCost")
acme$Sort("expectedCost", decreasing = TRUE)
print(acme, "expectedCost")
```

Naturally, you can also sort a subtree by calling Sort on the subtree's root node.


### Subclassing Node

We can create a subclass of Node, and add custom methods to our subclass. This is very natural to users with experience in OO languages such as Java, Python or C#:


```{r}
library(R6)
MyNode <- R6Class("MyNode",
                    inherit = Node,
                    lock = FALSE,
                    
                    #public fields and function
                    public = list(
                        p = NULL, 
                        cost = NULL,
                        AddChild = function(name) {
                          child <- MyNode$new(name)
                          invisible (self$AddChildNode(child))
                        }
                    ),
                    
                    #active
                    active = list(
                      expectedCost = function() {
                        if ( any(sapply(list(self$p, self$cost), is.null))) return (NULL)
                        self$p * self$cost                    
                      }
                    )
                )

```

The AddChild utility function in the subclass allows us to construct the tree just as before.

The expectedCost function is now a Method, and we can call it in a more R6-ish way.

