---
title: "Introduction to data.tree"
author: "Christoph Glur"
date: '`r Sys.Date()`'
output:
  html_document:
    includes:
      before_body: intro.banner.html
    self_contained: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
  pdf_document:
    toc: yes
    toc_depth: 3
---

<!--
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Quick introduction to data.tree}
-->

# Chapter 1: The basics

## About trees

Trees are ubiquitous in mathematics, computer science, data sciences, finance, and in many other fields. Trees are especially useful when we are facing *hierarchical data*. For example, trees are used:

* in decision theory (cf. decision trees)
* in machine learning (e.g. classification trees)
* in finance, e.g. to classify financial instruments into asset classes
* in routing algorithms
* in computer science and programming (e.g. binary search trees, XML)
* e.g. for family trees

## Trees in R

Tree-like structures are already used in R. For example, environments can be seen as nodes in a tree. And CRAN provides numerous packages that deal with tree-like structures, especially in the area of decision theory. Yet, there is no general purpose hierarchical data structure that could be used as conveniently and generically as, say, data.frame. 

As a result, people often try to resolve hierarchical problems in a tabular fashion, for instance with data.frames (or - perish the thought! - in Excel sheets). But often, hierarchies don't marry with tables and various workarounds are usually required. 

## What does data.tree offer

This package offers an alternative. The tree package allows you to create hierarchies, callde `data.tree` structures. The building block of theses structures are `Node` objects. `Node` provides basic traversal, search, and sort operations, and an infrastructure for recursive tree programming. You can decorate `Node`s with your own attributes and methods, so as to extend the package to your needs. 

The package also provides convenient methods for neatly printing trees, and converting trees to `data.frame`s, `lists`, and other tree structures such as `dendrogram`, `phylo` objects from the ape package, `igraph` and other packages.

The example in this vignette revolves around [decision trees](http://en.wikipedia.org/wiki/Decision_tree).

# Chapter 2

## Tree creation

### Create a tree programmatically

Let's start by creating a tree of `Node`s. In our example, we are looking at a company, Acme Inc., and the tree reflects its organisational structure. The root (level 0) is the company. On level 1, the nodes represent departments, and the leaves of the tree represent projects that the company is considering for next year:

```{r}
library(data.tree)
acme <- Node$new("Acme Inc.")
  accounting <- acme$AddChild("Accounting")
    software <- accounting$AddChild("New Software")
    standards <- accounting$AddChild("New Accounting Standards")
  research <- acme$AddChild("Research")
    newProductLine <- research$AddChild("New Product Line")
    newLabs <- research$AddChild("New Labs")
  it <- acme$AddChild("IT")
    outsource <- it$AddChild("Outsource")
    agile <- it$AddChild("Go agile")
    goToR <- it$AddChild("Switch to R")

print(acme)
```
Note that `Node` is an `R6` reference class. Essentially, this has two implications:

1. You can call methods on a `Node` in OO style
2. You can call methods on a `Node` that modify it, without having to re-assign to a new variable. This is different from the *value semantics*, which is much more widely used in R.

### Create a tree from a data.frame

Creating a tree programmatically is useful especially in the context of algorithms. However, most times you will create a try by conversion. This could be by conversion from a list-of-list, by conversion from another R tree-structure (e.g. an ape phylo), or by conversion from a `data.frame`. For more details on all the options type:

```{r eval=FALSE}
?as.Node
```

and refer to the See Also section.

One of the most common conversions is the one from a data.frame in table format. The following code illustrats this:

```{r}
library(treemap)
data(GNI2010)
#this data.frame is in table format, meaning that each row represents a
#leaf in the tree:
head(GNI2010)
#the pathString describes the hierarchy by defining a path from the
#root to each leaf. In this example, the hierarchy comes very naturally:
GNI2010$pathString <- paste("world", 
                            GNI2010$continent, 
                            GNI2010$country, 
                            sep = "/")

#conversion to Node is then very easy:
population <- as.Node(GNI2010)
print(population, "continent", "country", limit = 20)
```


### Create a tree from a file

Often, trees are created from one of many file formats. Typical import patterns could be:

* csv -> data.frame in table format (`?read.csv`) -> data.tree (`?as.Node.data.frame`)
* Newick -> ape phylo (`?ape::read.tree`) -> data.tree (`?as.Node.phylo` )
* csv -> data.frame in taxonomy / edge format (`?read.csv`) -> data.tree (c.f. `?FromDataFrameTaxonomy`)
* yaml -> list of lists (`?yaml::yaml.load`) -> data.tree (`?as.Node.list`, `demo('decisiontree', package='data.tree')`
* json -> list of lists (e.g. `?jsonlite::fromJSON`) -> data.tree (`?as.Node.list`)

If you have a choice, we recommend you consider yaml format, as it is concise, human-readable, and very easy to convert to a data.tree.


## Node methods

A `data.tree` structure is composed of `Node` objects, and the entry point to a `data.tree` structure is always a `Node`, typically the root `Node` of a tree.

There are different types of methods:

* OO-style actives (sometimes called properties) on `Node`s, such as e.g. `Node$isRoot`
* OO-style methods on `Node`s, such as e.g. `Node$Prune(pruneFun)`
* Classical R methods, such as e.g. `Clone(node)`. The main reason for these are not design considerations, but performance. As OO-style methods maintain their own "copy" of the function in each `Node` instance, OO-style methods are inflating memory usage of the `Node`s. For this reason, their use is kept to a minimum

### Actives Examples

Actives look like fields, but they are dynamically evaluated:

```{r}

population
population$isRoot
population$depth
population$count
population$totalCount
population$fields
population$totalFields
```



## Custom attributes

Now, let's associate some costs with the projects. We do this by setting custom attributes on the leaf `Node`s:
```{r}
software$cost <- 1000000
standards$cost <- 500000
newProductLine$cost <- 2000000
newLabs$cost <- 750000
outsource$cost <- 400000
agile$cost <- 250000
goToR$cost <- 50000

```
Also, we set the probabilities that the projects will be executed in the next year:

```{r}
software$p <- 0.5
standards$p <- 0.75
newProductLine$p <- 0.25
newLabs$p <- 0.9
outsource$p <- 0.2
agile$p <- 0.05
goToR$p <- 1

```

## Converting to `data.frame`

We can now convert the tree into a `data.frame`. Note that we always call such methods on the root `Node`:

```{r}
acmedf <- as.data.frame(acme)
```
The same can be achieved by using the OO-style method `Node$ToDataFrame`:
```{r, eval=FALSE}
acme$ToDataFrame()
```

Adding the project cost to our `data.frame` is easy to do with the `Get` method. We'll explain the `Get` method in more detail below.
```{r}
acmedf$level <- acme$Get("level")
acmedf$cost <- acme$Get("cost")
```

We could have achieved the same result in one go, using the OO-style `ToDataFrame` method:
```{r}
ToDataFrameTree(acme, "level", "cost")
```

Internally, the same is called when printing a tree:

```{r, eval=FALSE}
print(acme, "level", "cost")
```


### Using `Get` when converting to `data.frame` and for printing

Above, we saw how we can add the name of an attribute to the ellipsis argument of the `as.data.frame`. We can also add the results of the `Get` method directly to the `as.data.frame` . This allows, for example, formatting the column in a specific way. Details of the `Get` method are explained in the next section.

```{r}

ToDataFrameTree(acme, "level",
                probability = acme$Get("p", format = FormatPercent)
                )


```


# Chapter 2: Tree Traversal

## `Get` method (Tree Traversal)

Tree traversal is one of the core concepts of trees. See, for example, here: [Tree Traversal on Wikipedia](http://en.wikipedia.org/wiki/Tree_traversal).
The `Get` method traverses the tree and collects values from each node. It then returns a vector containing the collected values. 

Additional features of the `Get` method are:

* execute a function on each node, and append the function's result to the returned vector
* execute a `Node` method on each node, and append the method's return value to the returned vector
* assign the function or method return value to a `Node`'s attribute


### Traversal order

The `Get` method can traverse the tree in various ways. This is called traversal order.

#### Pre-Order

The default traversal mode is **pre-order**. 

![pre-order](assets/preorder.png)

This is what is used e.g. in `print`:

```{r}
print(acme, "level")
```

#### Post-Order

The **post-order** traversal mode returns children first, returning parents only after all children have been traversed:

![post-order](assets/postorder.png)

We can use it like this on the `Get` method:

```{r}
data.frame(level = acme$Get('level', traversal = "post-order"))
```

This is useful if your parent's value depends on the children, as we'll see below.

#### Ancestor

This is a non-standard traversal mode that does not traverse the entire tree. Instead, the ancestor mode starts from a `Node`, then walks the tree along the path from ancestor to ancestor, up to the root.

```{r}

data.frame(level = agile$Get('level', traversal = "ancestor"))

```

### `Get` using a function

#### Pass a function to the `Get` method

You can pass a standard R function to the `Get` method. For example:

```{r}

ExpectedCost <- function(node) {
  result <- node$cost * node$p
  if(length(result) == 0) result <- NA
  return (result)
}

data.frame(ec = acme$Get(ExpectedCost))

```

The requirements for the function (`ExpectedCost` in the above example) are the following:

* the first argument of the function is a `Node`
* it needs to return a scalar


#### Using recursion

In the following examples, we use `magrittr` to enhance readability of the code. 

```{r}
library(magrittr)
ExpectedCost <- function(node) {
  result <- node$cost * node$p
  if(length(result) == 0) {
    if (node$isLeaf) result <- NA
    else {
      node$children %>% sapply(ExpectedCost) %>% sum -> result
    }
  }
  return (result)
}

data.frame(ec = acme$Get(ExpectedCost))

```

#### Add parameters to the passed function

The `Traverse` method accepts an ellipsis (`...`). Any additional parameters with which `Get` is called will be passed on to the `ExpectedCost` function. This gives us more flexibility. For instance, we don't have to hard-code the `sum` function into `ExpectedCost`, but we can leave it to the caller to provide the function to use:

```{r}

ExpectedCost <- function(node, fun = sum) {
  result <- node$cost * node$p
  if(length(result) == 0) {
    if (node$isLeaf) result <- NA
    else {
      node$children %>% sapply(function(x) ExpectedCost(x, fun = fun)) %>% fun -> result
    }
  }
  return (result)
}

data.frame(ec = acme$Get(ExpectedCost, fun = mean))

```


### Assigning values using `Do`

We can tell the `Do` method to assign the value to a specific attribute for each `Node` it traverses. This is especially useful if the attribute parameter is a function, as in the previous examples. For instance, we can store the calculated expected cost for later use and printing:

```{r}

acme$Do(function(x) x$expectedCost <- x$p * x$cost)
print(acme, "p", "cost", "expectedCost")

```


### Combine assignment and calculation

In the above recursion example, we iterate - for each node - to all descendants straight to the leaf, repeating the very same calculations various times.

We can avoid repeating calculations by piggy-backing on precalculated values. Obviously, this requires us to traverse the tree in post-order mode: We want to start calculating at the leaves, cache the results for later use, then walk back towards the root.

In the following example, we calculate the average expected cost, just as above. As this now depends only on a `Node`'s children, and because we walk the tree in post-order mode, we can be sure that our children have the value calculated when we traverse the parent.


```{r}

SetExpectedCost <- function(node, variableName = "avgExpectedCost", aggfun = sum) {
  #if the "cache" is filled, I return it. This stops the recursion
  if(length(node[[variableName]]) > 0) return (node[[variableName]])
  
  #otherwise, I calculate from my own properties
  node[[variableName]] <- node$cost * node$p
  
  #if the properties are not set, I calculate the mean from my children
  if(length(node[[variableName]]) == 0) {
    if (node$isLeaf) stop("All leaves must have cost and p set")
    node[[variableName]] <- aggfun(sapply(node$children, function(x) x[[variableName]]))    
  }
}

```

We can use our method like this:

```{r}

acme$Do(SetExpectedCost, aggfun = mean, traversal = "post-order")

print(acme, "cost", "p", "avgExpectedCost")

```


### Formatting `Get`

We can pass a formatting function to the `Get` method, which will convert the returned value to a human-readable string for printing. 

```{r}

PrintMoney <- function(x) {
  format(x, digits=10, nsmall=2, decimal.mark=".", big.mark="'", scientific = FALSE)
}

print(acme, cost = acme$Get("cost", format = PrintMoney))

```

The `format` function is useful not only for formatting numbers, but also for displaying a printable representation of a `Node` field that is not a numeric (but e.g. a `matrix`).


## `Set` method

The `Set` method is the counterpart to the `Get` method. The `Set` method takes a vector or a single value as an input, and traverses the tree in a certain order. Each `Node` is assigned a value from the vector, one after the other.

### Assigning values


```{r}
employees <- c(NA, 52, NA, NA, 78, NA, NA, 39, NA, NA, NA)
acme$Set(employees)
print(acme, "employees")
```

The `Set` method can take multiple vectors as an input, and, optionally, you can define the name of the attribute:

```{r}
secretaries <- c(NA, 5, NA, NA, 6, NA, NA, 2, NA, NA, NA)
acme$Set(secretaries, secPerEmployee = secretaries/employees)
print(acme, "employees", "secretaries", "secPerEmployee")


```


Just as for the `Get` method, the **traversal order** is important for the `Set`.

Often, it is useful to use `Get` and `Set` together:

```{r}
ec <- acme$Get(function(x) x$p * x$cost)
acme$Set(expectedCost = ec)
print(acme, "p", "cost", "expectedCost")

```

### Deleting attributes

The `Set` method can also be used to assign a single value directly to all `Node`s traversed. For example, to remove the `avgExpectedCost`, we assign `NULL` on each node:

```{r}
acme$Set(avgExpectedCost = NULL)
```
Note that unassigned values also have `NULL`:
```{r}
acme$newAttribute
```

As a consequence, the value is not truely deleted:

```{r}
acme$fieldsAll
```

If we need to make sure that a variable is deleted for good, we do this:

```{r}
acme$Do(function(x) rm(avgExpectedCost, envir = x))
acme$fieldsAll
```


### Chaining

As `Node` is an R6 reference object, we can **chain** the arguments:

```{r}
acme$Set(avgExpectedCost = NULL)$Set(expectedCost = NA)
print(acme, "avgExpectedCost", "expectedCost")
```

This is equivalent to:
```{r}
acme$Set(avgExpectedCost = NULL, expectedCost = NA)
```


### A word on `Null` and `NA`

Also note that setting a value to `NA` or to `NULL` looks equivalent when printing to a data.frame, but internally it is not:

```{r}
acme$avgExpectedCost
acme$expectedCost
```

The reason is that `NULL` is always converted to NA for printing, and when using the `Get` method.


# Chapter 3: Advanced Features

## `Aggregate` method

For simple cases, you don't have to write your own function to be passed along to the `Get` method. For example, the `Aggregate` method provides a shorthand for the oft-used case when a parent is the aggregate of its children values:

```{r}

Aggregate(acme, "cost", sum)

```

We can use this in the `Get` method:

```{r}
acme$Get(Aggregate, "cost", sum)
```

This is the equivalent to:

```{r}
GetCost <- function(node) {
  result <- node$cost
  if(length(result) == 0) {
    if (node$isLeaf) stop(paste("Cost for ", node$name, " not available!"))
    else {
      node$children %>% sapply(GetCost) %>% sum -> result
    }
  }
  return (result)
}

acme$Get(GetCost)

```


## `Sort` method

You can sort an entire tree by using the `Sort` method on the root. The method will sort recursively and, for each `Node`, sort children by a child attribute. As before, the child attribute can also be a function or a method (e.g. of a sub-class of `Node`, see below).

```{r}
acme$Sort("name")
acme
acme$Sort(Aggregate, "cost", sum, decreasing = TRUE)
acme
```

Naturally, you can also sort a sub-tree by calling Sort on the sub-tree's parent node.

## `Clone` method

You can create a deep copy of a tree by using the `Clone` method on the root.

```{r}
data(acme)
acme2 <- Clone(acme)
#change the name on the clone:
acme2$name <- 'Acme2 Inc.'
#only the clone is changed, but not the original:
acme2$name != acme$name

```

## `ToList` method

You can convert a tree to a nested list by using the `ToList` method on the root.

```{r}
data(acme)
acmeList <- as.list(acme)
acmeList$IT$Outsource$cost
```

You can use `as.Node.List` to convert a nested list back into a tree:
```{r}
as.Node(acmeList)
```


### Explicit mode

You can use the explicit mode to save children in a nested list. You can call the `name` field and the `children` field differently, if you want:

```{r}
acmeList2 <- as.list(acme, mode = "explicit", nameName = 'id', childrenName = 'subNodes')
acmeList2$subNodes$IT$subNodes$Outsource$cost
```

You can also chose whether or not to have the nested lists named. This can be especially useful for conversion to JSON:

```{r}
acmeList3 <- as.list(acme, mode = "explicit", unname = TRUE)
acmeList3$children[[3]]$children[[1]]$cost
```


## Subclassing `Node`

We can create a subclass of `Node`, and add custom methods to our subclass. This comes naturally to users with experience in OO languages such as Java, Python or C#. See the R6 documentation for more details.


```{r}
library(R6)
MyNode <- R6Class("MyNode",
                    inherit = Node,
                    lock = FALSE,
                    
                    #public fields and function
                    public = list(
                        
                        p = NULL, 
                        
                        cost = NULL,
                        
                        AddChild = function(name) {
                          child <- MyNode$new(name)
                          invisible (self$AddChildNode(child))
                        }
                        
                    ),
                    
                    #active
                    active = list(
                      
                      expectedCost = function() {
                        if ( is.null(self$p) || is.null(self$cost)) return (NULL)
                        self$p * self$cost                    
                      }
                      
                    )
                )

```

The `AddChild` utility function in the subclass allows us to construct the tree just as before.

The `expectedCost` function is now a Method, and we can call it in a more R6-ish way.

