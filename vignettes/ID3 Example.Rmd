---
title: "ID3 Classification using data.tree"
author: "Christoph Glur"
date: '`r Sys.Date()`'
output: 
  html_document:
    theme: united
    toc: yes
    toc_depth: 3
---

<!--
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Example of using data.tree for ID3 classification}
-->

# The ID3 algorithm

http://www.uni-weimar.de/medien/webis/teaching/lecturenotes/machine-learning/unit-en-decision-trees-algorithms.pdf

This algorithm was one of the first ones

```{r}
library(data.tree)
data(mushrooms)
```

In ID3, the decision criteria is conditional entropy method:

```{r}
conditionalEntropy <- function( tble ) {
  tble <- as.data.frame.matrix(tble)
  tble$p <- rowSums(tble)/sum(tble)
  tble$a <- tble$edible / (tble$edible + tble$toxic)
  tble$b <- tble$toxic / (tble$edible + tble$toxic)
  -sum(tble$p * (tble$a * log2(tble$a) + tble$b * log2(tble$b)), na.rm = TRUE)
}
```


As a first recursion step we take the attribute having the largest information gain (i.e. the one with the smallest conditional entropy):
```{r}


train <- function(node) {
  
  if(FALSE) {
    if(is.null(dim(node$obs))) {
      #browser()
      node$obsCount <- length(node$obs)
      t <- table(node$obs)
      for(l in levels(node$obs)) {
        node[[l]] <- t[[l]]
      }
      return()
    } 
  }
    
  node$obsCount <- dim(node$obs)[1]
  x <- node$obs[,ncol(node$obs)]
  t <- table(x)
  for(l in levels(x)) {
    node[[l]] <- t[[l]]
  }

  #check if pure
  browser()
  if (length(unique(x)) == 1) {
    node$x <- node$obs[[1]]
    return()
  }
  
  #calculate conditional entropy for each attribute
  h <- sapply(colnames(node$obs)[-dim(node$obs)[2]], 
            function(x) conditionalEntropy(
              table(node$obs[,x], node$obs$edible)
              )
            )

  
  
  #select the attribute with the highest information gain (i.e. the one with the smalles conditional entropy)
  attribute <- names(h)[h == min(h)][1]
  node$entropy <- h[attribute]
  
  #find the next level observations
  childObs <- split(node$obs[,!(names(node$obs) %in% attribute)], node$obs[,attribute], drop = TRUE)
  
  #for each, create a child node and recursively call id3
  
  for(i in 1:length(childObs)) {
      
      child <- node$AddChild(names(childObs)[i])
      child$attribute <- attribute
      child$obs <- childObs[[i]]
      id3(child)
    
  }
  
  
}
```

We are ready to run the function:

```{r}
tree <- Node$new("root")
tree$obs <- mushrooms
train(tree)

print(tree, "attribute", "x", "obsCount", "edible", "toxic")

```

